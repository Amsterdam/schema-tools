import os

import click
import requests

import jsonschema as js
import ndjson
from amsterdam_schema.utils import schema_def_from_url
from shapely.geometry import shape
from sqlalchemy import MetaData, create_engine
from sqlalchemy.exc import SQLAlchemyError

from .create_schema import fetch_schema_for, fetch_schema_from_relational_schema
from .db import (
    create_meta_table_data,
    create_meta_tables,
    create_rows,
    fetch_table_names,
)

SCHEMA_URL = os.getenv("SCHEMA_URL")
metadata = MetaData()


def _get_engine(db_url):
    """Initialize the SQLAlchemy engine, and report click errors"""
    try:
        return create_engine(db_url)
    except SQLAlchemyError as e:
        raise click.BadParameter(str(e), param_hint="--db-url")


def fetch_rows(fh, srid):
    data = ndjson.load(fh)
    for row in data:
        row["geometry"] = f"SRID={srid};{shape(row['geometry']).wkt}"
        yield row


@click.group()
def schema():
    """ Main command to work with amsterdam schema files (jsonschema) from the command-line """
    pass


@schema.group()
def generate():
    """ Generate datbase tables mimicking amsterdam schema json
        or database records for a specific dataset.
    """
    pass


@schema.group()
def fetch():
    pass


@schema.command()
@click.argument("meta_schema_url")
@click.argument("schema_url")
def validate(meta_schema_url, schema_url):
    """ Validate an amsterdam schema json against the
        amsterdam schema meta schema.
    """
    response = requests.get(meta_schema_url)
    schema = response.json()
    response = requests.get(schema_url)
    instance = response.json()
    js.validate(instance=instance, schema=schema)


@fetch.command()
@click.option(
    "--db-url",
    envvar="DATABASE_URL",
    required=True,
    help="DSN of database, can also use DATABASE_URL environment.",
)
def tablenames(db_url):
    """ Return a list of available tables in the database specified
        by DATABASE_URL
    """
    engine = _get_engine(db_url)
    print("\n".join(fetch_table_names(engine)))


@schema.command()
@click.option("--prefix", "-p", help="Tables have prefix that needs to be stripped")
@click.option(
    "--db-url",
    envvar="DATABASE_URL",
    required=True,
    help="DSN of database, can also use DATABASE_URL environment.",
)
@click.argument("dataset_id")
@click.argument("tables", nargs=-1)
def introspect(prefix, db_url, dataset_id, tables):
    """ Return the amsterdam schema json for the specified set of tables in a database.
        The jsonschema is generated by introspecting the relational database
    """

    engine = _get_engine(db_url)
    print(fetch_schema_for(engine, dataset_id, tables, prefix))


@generate.command()
@click.option(
    "--db-url",
    envvar="DATABASE_URL",
    required=True,
    help="DSN of database, can also use DATABASE_URL environment.",
)
@click.option(
    "--schema-url",
    envvar="SCHEMA_URL",
    required=True,
    help="Url where valid amsterdam schema files are found. "
    "SCHEMA_URL can also be provided as  environment variable.",
)
@click.argument("schema_name")
@click.argument("table_name")
@click.argument("ndjson_path")
def records(db_url, schema_url, schema_name, table_name, ndjson_path):
    """ Load database records for a specific dataset from an ndjson file.
    """
    # Add batching for rows.
    engine = _get_engine(db_url)
    dataset_schema = schema_def_from_url(schema_url, schema_name)
    srid = dataset_schema["crs"].split(":")[-1]
    with open(ndjson_path) as fh:
        data = list(fetch_rows(fh, srid))
    create_rows(engine, metadata, dataset_schema, table_name, data)


@generate.command()
@click.option(
    "--db-url",
    envvar="DATABASE_URL",
    required=True,
    help="DSN of database, can also use DATABASE_URL environment.",
)
@click.option(
    "--schema-url",
    envvar="SCHEMA_URL",
    required=True,
    help="Url where valid amsterdam schema files are found. "
    "SCHEMA_URL can also be provided as  environment variable.",
)
@click.argument("dataset_id")
def arschema(db_url, schema_url, dataset_id):
    """ Generate postgres tables from an existing amsterdam schema json file. """
    # XXX Add drop or not flag
    engine = _get_engine(db_url)
    try:
        dataset_schema = schema_def_from_url(schema_url, dataset_id)
    except KeyError:
        raise click.BadParameter(f"Schema {dataset_id} not found.")

    create_meta_tables(engine)
    create_meta_table_data(engine, dataset_schema)


@fetch.command("schema")
@click.option(
    "--db-url",
    envvar="DATABASE_URL",
    required=True,
    help="DSN of database, can also use DATABASE_URL environment.",
)
@click.argument("dataset_id")
def _schema(db_url, dataset_id):
    """ Fetch an amsterdam schema (json) file from postgres tables representing
        amsterdam schema in relational db format.
    """
    engine = _get_engine(db_url)
    try:
        json_schema = fetch_schema_from_relational_schema(engine, dataset_id)
    except ValueError:
        raise click.BadParameter(f"Schema {dataset_id} not found.")
    click.echo(json_schema)
